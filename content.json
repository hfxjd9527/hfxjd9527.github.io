{"meta":{"title":"StarryMusic","subtitle":null,"description":"好少年光芒万丈","author":"liruochen","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2024-01-11T10:39:04.563Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[星空の博客] 与&nbsp; 星空&nbsp; 对话中... bot_ui_ini()","keywords":"关于"},{"title":"code","date":"2019-01-05T13:47:59.000Z","updated":"2024-01-11T10:39:04.564Z","comments":false,"path":"code/index.html","permalink":"/code/index.html","excerpt":"","text":"sakura主题balabala","keywords":"code"},{"title":"categories","date":"2020-12-07T03:19:29.000Z","updated":"2024-01-11T10:39:04.564Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2024-01-11T10:39:04.564Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"essay","date":"2018-12-20T15:13:05.000Z","updated":"2024-01-11T10:39:04.564Z","comments":false,"path":"essay/index.html","permalink":"/essay/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2024-01-11T10:39:04.564Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2024-01-11T10:39:04.564Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2024-01-11T10:39:04.566Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2024-01-11T10:39:04.567Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"我的歌单"},{"title":"tec","date":"2020-07-07T02:05:00.000Z","updated":"2024-01-11T10:39:04.567Z","comments":true,"path":"tec/index.html","permalink":"/tec/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2024-01-11T10:39:04.567Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2024-01-11T10:39:04.567Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '成长', status: '越长大，越孤单；越长大，越不安。', progress: 100, desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"dream","date":"2019-02-10T13:32:48.000Z","updated":"2024-01-19T06:51:59.590Z","comments":false,"path":"dream/index.html","permalink":"/dream/index.html","excerpt":"","text":"","keywords":null},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2024-01-11T10:39:04.567Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2024-01-11T10:39:04.567Z","comments":false,"path":"tec/software/index.html","permalink":"/tec/software/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"02-GitLab CI/CD功能简介","slug":"2.Gitlab_CICD简介","date":"2024-01-11T10:39:04.561Z","updated":"2024-01-11T10:39:04.562Z","comments":true,"path":"2024/01/11/2.Gitlab_CICD简介/","link":"","permalink":"/2024/01/11/2.Gitlab_CICD简介/","excerpt":"","text":"02-GitLab CI/CD功能简介GitLab 内置持续集成功能持续集成 （CI） 集成团队中每个开发人员提交的代码到代码存储库中。 开发人员在Merge或者Pull请求中合并拉取新代码。 在提交或者合并更改到代码存储库之前，会触发了构建，测试和新代码验证的管道。 CI可帮助您在开发周期的早期发现并减少错误 连续交付 （CD） 可通过结构化的部署管道确保将经过CI验证的代码交付给您的应用程序。 CD可以将经过验证的代码更快地移至您的应用程序。 CI/CD 一起 可以加快团队为客户和利益相关者交付成果的速度。CI和CD必须无缝协作，以使您的团队快速有效地进行构建，并且对于确保完全优化的开发实践至关重要。 GitLab CI/CD优势 开源： CI/CD是开源GitLab社区版和专有GitLab企业版的一部分。 易于学习： 具有详细的入门文档。 无缝集成： GitLab CI / CD是GitLab的一部分，支持从计划到部署,具有出色的用户体验。 可扩展： 测试可以在单独的计算机上分布式运行，可以根据需要添加任意数量的计算机。 更快的结果： 每个构建可以拆分为多个作业，这些作业可以在多台计算机上并行运行。 针对交付进行了优化： 多个阶段，手动部署， 环境 和 变量。 GitLab CI/CD特点 多平台： Unix，Windows，macOS和任何其他支持Go的平台上执行构建。 多语言： 构建脚本是命令行驱动的，并且可以与Java，PHP，Ruby，C和任何其他语言一起使用。 稳定构建： 构建在与GitLab不同的机器上运行。 并行构建： GitLab CI / CD在多台机器上拆分构建，以实现快速执行。 实时日志记录： 合并请求中的链接将您带到动态更新的当前构建日志。 灵活的管道： 您可以在每个阶段定义多个并行作业，并且可以 触发其他构建。 版本管道： 一个 .gitlab-ci.yml文件 包含您的测试，整个过程的步骤，使每个人都能贡献更改，并确保每个分支获得所需的管道。 自动缩放： 您可以 自动缩放构建机器，以确保立即处理您的构建并将成本降至最低。 构建工件： 您可以将二进制文件和其他构建工件上载到 GitLab并浏览和下载它们。 Docker支持： 可以使用自定义Docker映像， 作为测试的一部分启动 服务， 构建新的Docker映像，甚至可以在Kubernetes上运行。 容器注册表： 内置的容器注册表， 用于存储，共享和使用容器映像。 受保护的变量： 在部署期间使用受每个环境保护的变量安全地存储和使用机密。 环境： 定义多个环境。 GitLab CI/CD架构GitLab CI / CDGitLab的一部分，GitLab是一个Web应用程序，具有将其状态存储在数据库中的API。除了GitLab的所有功能之外，它还管理项目/构建并提供一个不错的用户界面。 GitLab Runner是一个处理构建的应用程序。它可以单独部署，并通过API与GitLab CI / CD一起使用。 .gitlab-ci.yml定义流水线作业运行，位于应用项目根目录下 。 为了运行测试，至少需要一个 GitLab 实例、一个 GitLab Runner、一个gitlab-ci文件 GitLab CI/CD工作原理 将代码托管到Git存储库。 在项目根目录创建ci文件 .gitlab-ci.yml ，在文件中指定构建，测试和部署脚本。 GitLab将检测到它并使用名为GitLab Runner的工具运行脚本。 脚本被分组为作业，它们共同组成了一个管道。 管道状态也会由GitLab显示： 最后，如果出现任何问题，可以轻松地 回滚所有更改：","categories":[],"tags":[{"name":"devops","slug":"devops","permalink":"/tec/devops/"}],"keywords":[]},{"title":"输出集群中使用了mysql或者pg的deployment","slug":"输出集群中使用了mysql或者pg的deployment","date":"2021-04-20T13:29:01.000Z","updated":"2024-01-11T10:39:04.563Z","comments":true,"path":"2021/04/20/输出集群中使用了mysql或者pg的deployment/","link":"","permalink":"/2021/04/20/输出集群中使用了mysql或者pg的deployment/","excerpt":"","text":"第一针对configmap中有配置相关数据库信息的服务脚本中有用到jq工具 输出当前环境下有配置configmap的deployment的名称strconfig=&quot;config&quot; for line in `kubectl get deployment | awk &#39;{print $1}&#39;` do name=`kubectl get deployment $line -ojson|jq .spec.template.spec.volumes | grep name` #echo $line $name result=$(echo $name | grep &quot;${strconfig}&quot;) if [ -n &quot;$result&quot; ]; then echo $line fi done 输出当前集群命名空间下有配置configmap的deployment的configmap的名称strconfig=&quot;config&quot; for line in `kubectl get deployment | awk &#39;{print $1}&#39;` do name=`kubectl get deployment $line -ojson|jq .spec.template.spec.volumes | grep name` result=$(echo $name | grep &quot;${strconfig}&quot;) if [ -n &quot;$result&quot; ]; then for configname in `echo $name | awk &#39;{print $2}&#39;| sed &#39;s/\\&quot;//g&#39;` do echo ${configname%?} done fi done 输出带有pg或者mysql的configMapNamestrconfig=&quot;config&quot; str=&quot;\\-config&quot; for line in `kubectl get deployment | awk &#39;{print $1}&#39;` do name=`kubectl get deployment $line -ojson|jq .spec.template.spec.volumes | grep name` result=$(echo $name | grep &quot;${strconfig}&quot;) if [ -n &quot;$result&quot; ]; then for finalresult in `echo $name | awk &#39;{print $0}&#39;| sed &#39;s/\\&quot;//g&#39;` do configname=$(echo $finalresult | grep &quot;${str}&quot;) if [ -n &quot;$configname&quot; ]; then finalConfigName=`echo $configname | sed -e &#39;s/,//g&#39;` has_mysql=`kubectl get configmap $finalConfigName -o yaml | grep mysql` if [ -n &quot;$has_mysql&quot; ]; then echo &quot;has mysql&quot; $finalConfigName fi has_pg=`kubectl get configmap $finalConfigName -o yaml | grep pg` if [ -n &quot;$has_pg&quot; ]; then echo &quot;has pg&quot; $finalConfigName fi fi done fi done 输出带有pg或者mysql的deploymentstrconfig=&quot;config&quot; str=&quot;\\-config&quot; for line in `kubectl get deployment | awk &#39;{print $1}&#39;` do name=`kubectl get deployment $line -ojson|jq .spec.template.spec.volumes | grep name` result=$(echo $name | grep &quot;${strconfig}&quot;) if [ -n &quot;$result&quot; ]; then for finalresult in `echo $name | awk &#39;{print $0}&#39;| sed &#39;s/\\&quot;//g&#39;` do configname=$(echo $finalresult | grep &quot;${str}&quot;) if [ -n &quot;$configname&quot; ]; then finalConfigName=`echo $configname | sed -e &#39;s/,//g&#39;` has_mysql=`kubectl get configmap $finalConfigName -o yaml | grep mysql` if [ -n &quot;$has_mysql&quot; ]; then echo &quot;has mysql&quot; $line fi has_pg=`kubectl get configmap $finalConfigName -o yaml | grep pg` if [ -n &quot;$has_pg&quot; ]; then echo &quot;has pg&quot; $line fi fi done fi done 第二针对环境变量中有配置相关数据库信息的服务这个比较简单，直接查看deployment的yaml文件即可 kubectl get deploy deployment_name -o yaml | grep mysql 综合后shell脚本如下strconfig=&quot;config&quot; str=&quot;\\-config&quot; function get_deployment_from_configmap(){ for line in `kubectl get deployment | awk &#39;{if (NR&gt;1) print $1}&#39;` do name=`kubectl get deployment $line -ojson|jq .spec.template.spec.volumes | grep name` result=$(echo $name | grep &quot;${strconfig}&quot;) if [ -n &quot;$result&quot; ]; then for finalresult in `echo $name | awk &#39;{print $0}&#39;| sed &#39;s/\\&quot;//g&#39;` do configname=$(echo $finalresult | grep &quot;${str}&quot;) if [ -n &quot;$configname&quot; ]; then finalConfigName=`echo $configname | sed -e &#39;s/,//g&#39;` has_mysql=`kubectl get configmap $finalConfigName -o yaml | grep mysql` if [ -n &quot;$has_mysql&quot; ]; then echo &quot;该服务在configMap中引用了mysql&quot; $line fi has_pg=`kubectl get configmap $finalConfigName -o yaml | grep pg` if [ -n &quot;$has_pg&quot; ]; then echo &quot;该服务在configMap中引用了pg&quot; $line fi fi done fi done } function get_deployment_from_env(){ str_mysql=&quot;mysql&quot; str_pg=&quot;pg&quot; for line in `kubectl get deployment | awk &#39;{if (NR&gt;1) print $1}&#39;` do name=`kubectl get deploy $line -o yaml | grep mysql` mysql_result=$(echo $name | grep &quot;${str_mysql}&quot;) if [ -n &quot;$mysql_result&quot; ]; then echo &quot;该服务在环境变量中引用了mysql:&quot; $line fi pg_result=$(echo $name | grep &quot;${str_pg}&quot;) if [ -n &quot;$pg_result&quot; ]; then echo &quot;该服务在环境变量中引用了pg:&quot; $line fi done } function main(){ get_deployment_from_configmap get_deployment_from_env } main 以上配合集群管理工具使用更佳哦！","categories":[],"tags":[{"name":"devops","slug":"devops","permalink":"/tec/devops/"}],"keywords":[]},{"title":"k8s多集群管理工具kubectl+kubecm+kubectx","slug":"k8s多集群管理工具kubectl+kubecm+kubectx","date":"2021-03-28T13:29:01.000Z","updated":"2024-01-11T10:39:04.562Z","comments":true,"path":"2021/03/28/k8s多集群管理工具kubectl+kubecm+kubectx/","link":"","permalink":"/2021/03/28/k8s多集群管理工具kubectl+kubecm+kubectx/","excerpt":"","text":"kubectl安装与使用 1.安装kubecmmac电脑安装方式： brew install sunny0826/tap/kubecm 如果无法访问github或者访问较慢，需要科学上网 2.使用kubecm2.1.初次使用安装完成后，新建个文件夹，随便命名，比方叫做hexk8s，将rancher上kubeconfig文件复制下来放到该文件夹下，根据不同项目，给config文件起个名字。然后执行命令（回到hexk8s上级目录） kubecm merge -f hexk8s 选择true，让其overwite ~/.kube/config文件 2.2.添加项目config文件如果下次有新的项目config需要加进来，在该文件夹下，新建一个项目名-config文件，比如xiaomian-config kubecm add -f xiaomian-config 选择true让其overwrite 2.3.删除某个项目kubecm delete 按上下方向键选出自己要删的，回车，然后true，就可以删除了 ####2.4.选择自己要看的项目 kubecm switch 如果项目较多，可以像使用vim编辑文件一样，使用/查找，选中后，回车即可进到该项目，进到里面后，结下来的操作，就是kubectl之前的操作了 3.安装kubectx上面虽然可以切换项目，但是不能锁定namespace，查看pod还要带上-n namespace_name还是不够便捷先安装fzf模糊搜索，不分开讲它的使用，具体可参考：fzf brew install fzf kubectx的功能其实相当于kubecm switch，主要实现项目的切换 brew install kubectx 安装后，直接在终端输入kubectx，就可以选择自己要进去的项目，前提是有过上面那种配置kubens命令可以看到当前环境所有的namespace，可以快速选择NS，选择NS之后执行的命令就是在当前NS中执行了，比如执行kubectl get pods 显示的就是当前NS所有的pod，不需要加上-n xxxx","categories":[],"tags":[{"name":"devops","slug":"devops","permalink":"/tec/devops/"}],"keywords":[]},{"title":"在k8s集群部署Jenkins服务","slug":"在k8s集群部署Jenkins服务","date":"2021-03-21T12:29:01.000Z","updated":"2024-01-11T10:39:04.563Z","comments":true,"path":"2021/03/21/在k8s集群部署Jenkins服务/","link":"","permalink":"/2021/03/21/在k8s集群部署Jenkins服务/","excerpt":"","text":"第一次部署jenkins服务时，镜像中缺少一些Jenkins服务需要的依赖环境，在使用过程中有很多问题，后来选用其他镜像，并为其配置好相关环境后，打包成一个新的镜像，最后在rancher上替换掉当前镜像地址。下面会贴出整个服务的配置文件，是可移植的。以下操作分别是在Mac、Mac的虚拟机和容器之间切换操作。 具体操作# 在虚拟机上的操作 # 使用一个相对稳定的镜像 docker pull jenkinsci/blueocean # 查看pull的结果 docker images | grep jenkins # 启动Jenkins docker run -d --name jenkins -u root -p 9090:8080 -v /var/jenkins_home:/var/jenkins_home jenkinsci/blueocean # 查看Jenkins容器 docker ps | grep jenkins # 进到容器里面 docker exec -it 0f5832ffb8a0 bash # 下面是在容器中的操作 # 查看apk命令帮助 apk -h # 安装一些常用的工具 # 安装maven apk add maven # 查看maven相关信息 apk info -L maven # 查看git信息 apk info -L git # 查看是否有Java环境 echo $JAVA_HOME # 安装一些常用的工具 apk add gcc apk add yum apk add wget # 安装allure cd /usr/local/ mkdir src cd src/ # 容器内操作结束 # 在Mac电脑上下载allure-2.13.8.tgz # 下载链接：https://github.com/allure-framework/allure2/releases # 下载后，使用scp命令将其拷贝到虚拟机 scp allure-2.13.8.tgz root@172.16.26.101:/root # 然后再从虚拟机拷贝到容器内部 docker cp allure-2.13.8.tgz 0f5832ffb8a0:/usr/local/src/allure-2.13.8.tgz # 进到容器内继续操作 docker exec -it 0f5832ffb8a0 bash cd /usr/local/src # 解压 tar -zxvf allure-2.13.8.tgz mv allure-2.13.8 allure # 创建软连接 ln -s /usr/local/src/allure/bin/allure /usr/bin/allure # 验证 allure allure --version # 退出容器 # 在虚拟机上将当前正在运行的容器打包成镜像，推送到自己docker-hub上 docker commit -a &quot;hex&quot; -m &quot;hex-jenkins&quot; 0f5832ffb8a0 jenkins:0318 docker images docker tag jenkins:0318 131412127/jenkins:0318 docker login docker push 131412127/jenkins:0318 # 推送到公司镜像仓库 docker tag jenkins:0318 registry.XXXXXXX.cn/jenkins:0318 docker login registry.XXXXXXX.cn docker push registry.XXXXXXX.cn/jenkins:0318 # 到rancher上替换成这个镜像 # 如果想要看自己虚拟机上运行的这个Jenkins # 在容器内查看Jenkins登录密码 cat /var/jenkins_home/secrets/initialAdminPassword # 有密码后，就可以在浏览器中访问：http://172.16.26.101:9090/ 相关配置文件以下是在k8s集群中搭建jenkins服务用到的相关配置文件 jenkins-service-account.yaml--- apiVersion: v1 kind: ServiceAccount metadata: name: jenkins --- kind: Role apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: jenkins rules: - apiGroups: [&quot;&quot;] resources: [&quot;pods&quot;] verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;] - apiGroups: [&quot;&quot;] resources: [&quot;pods/exec&quot;] verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;] - apiGroups: [&quot;&quot;] resources: [&quot;pods/log&quot;] verbs: [&quot;get&quot;,&quot;list&quot;,&quot;watch&quot;] - apiGroups: [&quot;&quot;] resources: [&quot;secrets&quot;] verbs: [&quot;get&quot;] --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: RoleBinding metadata: name: jenkins roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: jenkins subjects: - kind: ServiceAccount name: jenkins jenkins-statefulset.yamlapiVersion: apps/v1 kind: StatefulSet metadata: labels: name: jenkins name: jenkins namespace: qa spec: podManagementPolicy: OrderedReady replicas: 1 revisionHistoryLimit: 10 selector: matchLabels: name: jenkins serviceName: jenkins template: metadata: labels: name: jenkins name: jenkins spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: jenkins operator: In values: - &quot;true&quot; containers: - command: - /sbin/tini - /usr/local/bin/jenkins.sh - --prefix=/jenkins env: - name: ALLURE_HOME value: /var/jenkins_home/allure/package/ - name: JAVA_OPTS value: -Xmx512m -XshowSettings:vm -Dhudson.slaves.NodeProvisioner.initialDelay=0 -Dhudson.slaves.NodeProvisioner.MARGIN=50 -Dhudson.slaves.NodeProvisioner.MARGIN0=0.85 -D--prefix=/jenkins -Duser.timezone=Asia/Shanghai -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true - name: MAVEN_HOME value: /var/jenkins_home/maven/ - name: PATH value: /opt/java/openjdk/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/var/jenkins_home/maven/bin - name: LIMITS_MEMORY valueFrom: resourceFieldRef: divisor: &quot;0&quot; resource: limits.memory image: registry.hexcloud.cn/jenkins:0318 imagePullPolicy: Always livenessProbe: failureThreshold: 12 httpGet: path: /jenkins/login port: 8080 scheme: HTTP initialDelaySeconds: 60 periodSeconds: 10 successThreshold: 1 timeoutSeconds: 5 name: jenkins ports: - containerPort: 8080 name: 8080tcp02 protocol: TCP - containerPort: 50000 name: 50000tcp02 protocol: TCP readinessProbe: failureThreshold: 12 httpGet: path: /jenkins/login port: 8080 scheme: HTTP initialDelaySeconds: 60 periodSeconds: 10 successThreshold: 1 timeoutSeconds: 5 resources: requests: cpu: 500m memory: 500Mi securityContext: capabilities: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /var/jenkins_home name: jenkins-home dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: fsGroup: 1000 serviceAccount: jenkins serviceAccountName: jenkins terminationGracePeriodSeconds: 10 volumes: - hostPath: path: /data/jenkins type: &quot;&quot; name: jenkins-home updateStrategy: type: RollingUpdate jenkins-ingress.yamlapiVersion: extensions/v1beta1 kind: Ingress metadata: name: jenkins namespace: qa spec: rules: - host: jenkins.XXXXXXX.cn http: paths: - backend: serviceName: jenkins servicePort: 80 path: /jenkins jenkins-service.yamlapiVersion: v1 kind: Service metadata: name: jenkins namespace: qa spec: ports: - name: http port: 80 protocol: TCP targetPort: 8080 - name: agent port: 50000 protocol: TCP targetPort: 50000 selector: name: jenkins sessionAffinity: None type: ClusterIP 注意事项：如果将上述文件部署在其他命名空间下，需要修改下上面文件的命名空间，修改下域名，给要部署的主机加上一个标签。kubectl label nodes k8s-node01 jenkins=true如在rancher上遇到：Readiness probe failed: HTTP probe failed with statuscode: 503原因可能是master节点的集群ip映射了5台机器，实际master只有3台，导致访问出错，解决方式，换一台主机，重新打标签。","categories":[],"tags":[{"name":"devops","slug":"devops","permalink":"/tec/devops/"}],"keywords":[]},{"title":"pg数据库恢复","slug":"pg数据库恢复","date":"2021-03-14T13:00:01.000Z","updated":"2024-01-11T10:39:04.562Z","comments":true,"path":"2021/03/14/pg数据库恢复/","link":"","permalink":"/2021/03/14/pg数据库恢复/","excerpt":"","text":"问题描述：DQ想要下载2018年的raps报表数据，但是数据库中没有完整版的数据，最早是2018年12月份的数据，之前devops有物理备份过pg数据库，所以现在有个需求就是将这部分数据恢复出来问题解决：整库备份它长这个样子： 1.知道这是物理备份，先在虚拟机上实操一下1.1.安装相同版本的pg安装PostgreSQL9.6将新的PostgreSQL 9.6存储库添加到系统中 yum -y install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7.4-x86_64/pgdg-redhat-repo-latest.noarch.rpm 现在使用下面的yum命令安装PostgreSQL 9.6 yum -y install postgresql96-server postgresql96-contrib 启动并配置PostgreSQL 9.6在开始postgres服务之前，我们需要初始化数据库。 cd /usr/pgsql-9.6/bin ./postgresql96-setup initdb 接下来，启动postgres服务，并启用它在系统启动时自动启动。 systemctl start postgresql-9.6 systemctl enable postgresql-9.6 默认情况下，postgres在端口5432上运行。所以通过执行netstat命令来确保端口5432的状态是’ LISTEN ‘ netstat -plntu 如果您没有netstat命令，请安装net-tools。 这是网络工具的一部分 yum -y install net-tools 所以PostgreSQL 9.6已经启动了。 但是我们仍然需要为postgres用户配置密码。 以“postgres”用户身份登录，然后访问postgres的“psql”shell。 su - postgres psql 用下面的查询给’ postgres ‘用户设置新密码：juoperbhju90habfj#hg \\password postgres Enter new password: 所以PostgreSQL 9.6已经启动了，并为postgres用户配置了一个新的密码。安装好后，使用navicat连接试一下，能连接上就OK了 1.2.挪动pg数据库默认的存放数据的文件夹到/data目录下这一步的操作原因是只有data目录下才有比较大的空间供我解压一个近200G的压缩文件在换路径前先关掉pg数据库 systemctl stop postgresql-9.6.service 然后复制pg数据库默认的存放数据的文件夹到/data目录下 sudo cp -rf /var/lib/pgsql/9.6/data /data/pgsql/ 挪动后，设置用户和权限 cd /data/ sudo chown -R postgres:postgres pgsql/ sudo chmod 700 pgsql/ 修改pg数据库的service文件 vim /usr/lib/systemd/system/postgresql-9.6.service 将默认加载文件指向自己想要的路径 Environment=PGDATA=/data/pgsql/ 修改PGDATA路径之后，就可以执行下面的命令让其立即生效 sudo systemctl daemon-reload systemctl restart postgresql-9.6.service 如果不报错，万事大吉，如果报错，查看报错内容，解决报错问题如果报错内容说是找不到文件夹或者什么empty，那就是上面赋予权限问题没有做好，挪动一下，重新赋予权限即可查看是否属于某个用户或者用户组，下面这种是对的 2.实际恢复数据具体操作为了避免解压不完全，使用一个工具screen，因为毕竟近200G的压缩文件，解压后有近700G的文件，在解压时，不让其中断。 yum -y install screen 创建一个会话 screen -S 会话名称 例如，我想在这个会话中执行解压的命令，我可以创建下面这个会话 screen -S tarzxdq 然后就是正常的在终端中的常规操作进到某个文件夹下，执行解压命令，然后X掉这个终端，该干嘛干嘛 tar -zxvf full.tar.gz 查看会话列表： screen -ls 进入到某个会话 screen -r 会话名称 screen -r tarzxdq 有时在恢复 screen 时会出现 There is no screen to be resumed matching **，遇到这种情况，先退出这个会话，然后再进入 screen -d tarzxdq screen -r tarzxdq cd /data 将解压好的full文件夹复制到/data目录下，其实在原来目录应该也可以，只是尝试过失败很多次，有阴影了 mv restore_for_dq/full . 给文件夹赋予权限 sudo chown -R postgres:postgres full/ sudo chmod 700 full/ 拿到full文件夹路径 cd full/ pwd 修改service中PGDATA路径 vim /usr/lib/systemd/system/postgresql-9.6.service 生效变更 systemctl daemon-reload 重启数据库 systemctl restart postgresql-9.6.service 报错了：查看报错信息 journalctl -xe 将postgresql.conf先复制一份 cp postgresql.conf postgresql.conf.bak 再根据报错信息，将报错中提到的这个搜一下，全部注释掉，然后将logging_collector由on改成off 重启一下，继续报错 systemctl restart postgresql-9.6.service journalctl -xe 再次修改 vim postgresql.conf 将报错中的内容注释掉，再次重启 systemctl restart postgresql-9.6.service ls 成功了，但是不支持postgres连接，将连接用户名改成root然后将其改成信任所有连接，这样任何密码都能连上来 vim pg_hba.conf 将上面这行注释，下面新加一行改成信任 #host all all 127.0.0.1/32 ident host all all 127.0.0.1/32 trust 再次重启 systemctl restart postgresql-9.6.service 然后就可以连上来了","categories":[],"tags":[{"name":"devops","slug":"devops","permalink":"/tec/devops/"}],"keywords":[]},{"title":"mongo数据库备份与还原","slug":"mongo数据库备份与还原","date":"2021-03-13T13:00:01.000Z","updated":"2024-01-11T10:39:04.562Z","comments":true,"path":"2021/03/13/mongo数据库备份与还原/","link":"","permalink":"/2021/03/13/mongo数据库备份与还原/","excerpt":"","text":"公司在20年将客户19年及之前的数据给归档了，现在他们想要做BI项目，需要将这些数据给捞出来，这篇文章主要介绍mongo数据的备份与恢复。mongo及组件的安装参考文章 1.本地模拟先在虚拟机上模拟一下备份与还原，然后再实操 1.1.在虚拟机上安装配置mongo下面以安装mongodb3.x为例。mongoDB正式提供packge安装支持，在他们的仓库中包含下面的包： mongodb-org：这个包会自动安装下面所有的组件包 mongodb-org-server: 包含mongod，和相关配置和初始脚本 mongodb-org-mongos: 包含mongos mongodb-org-shell: 包含mongo脚本 mongodb-org-tools: 包含下面的mongodb工具：mongoimport bsondump,mongodump,mongoexport,mongofiles, mongoplog,mongoperf,mongorestore,mongostat和mongotop 创建yum仓库文件repo vi /etc/yum.repos.d/mongodb-org-3.2.repo [mongodb-org-3.2] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.2/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-3.2.asc 安装mongo及所有的mongodb组件： yum install -y mongodb-org-3.2.5 mongodb-org-server-3.2.5 mongodb-org-shell-3.2.5 mongodb-org-mongos-3.2.5 mongodb-org-tools-3.2.5 安装完成之后，为了防止意外升级，可以在/etc/yum.conf中加入下面的配置防止意外升级： exclude=mongodb-org,mongodb-org-server,mongodb-org-shell,mongodb-org-mongos,mongodb-org-tools 如果遇到启动失败的问题，可以关闭SELinux setenforce 0 启动mongo`shell scriptsystemctl start mongod 配置开机启动 ```shell systemctl enable mongod mongo设置账号密码（可以在navicat中通过查询的方式创建，选择admin数据库）： db.createUser( { user:&quot;root&quot;, pwd:&quot;123456&quot;, roles:[{role:&quot;root&quot;,db:&quot;admin&quot;}] } ); 以上，就可以使用navicat进行连接mongo了 1.2.如若卸载停止mongo systemctl stop mongod 卸载mongo删除之前安装的mongodb的相关包: yum erase $(rpm -qa | grep mongodb-org) 删除相关文件夹 sudo rm -r /var/log/mongodb sudo rm -r /var/lib/mongo 1.3.mongo的简单语法删除集合 db.getCollection(&quot;pos&quot;).drop(); 创建集合 db.createCollection(&quot;pos&quot;); 创建索引 db.getCollection(&quot;pos&quot;).createIndex({ hash: NumberInt(&quot;1&quot;) }, { name: &quot;hash&quot; }); db.getCollection(&quot;pos&quot;).createIndex({ &quot;sales_date&quot;: NumberInt(&quot;1&quot;) }, { name: &quot;sales_date&quot; }); 1.4.备份与还原参考文章备份一个集合：语法： mongodump --db database --collection collectionName 示例： mongodump --collection pos --db saas 有指向性的备份，在A机器上备份还原B机器上的数据也是可行的 mongodump --host 127.0.0.1 --port 27071 --collection pos --db saas_dq_uat 备份除集合1、集合2之外的所有集合 mongodump --db database --excludeCollection=collection1 --excludeCollection=collection2 还原一个集合 mongorestore --collection collection --db database filePath mongorestore --collection pos --db saas /root/mongobackup/dump/saas/pos.bson 在148机器上还原数据到147机器 mongorestore --host 192.168.2.147 --port 27071 --collection pos --db saas_dq_uat /data/backup/dq_mongodb/mongo_dq_pos_bak191023/pos.bson 备份满足一定条件的数据，参考文章","categories":[],"tags":[{"name":"devops","slug":"devops","permalink":"/tec/devops/"}],"keywords":[]},{"title":"kubectl 常用命令","slug":"kubectl常用指令","date":"2021-03-09T13:29:01.000Z","updated":"2024-01-11T10:39:04.562Z","comments":true,"path":"2021/03/09/kubectl常用指令/","link":"","permalink":"/2021/03/09/kubectl常用指令/","excerpt":"","text":"查看类命令：brew install sunny0826/tap/kubecm # 获取节点和服务版本信息 kubectl get nodes # 获取节点和服务版本信息，并查看附加信息 kubectl get nodes -o wide # 获取pod信息，默认是default名称空间 kubectl get pod # 获取pod信息，默认是default名称空间，并查看附加信息【如：pod的IP及在哪个节点运行】 kubectl get pod -o wide # 获取指定名称空间的pod kubectl get pod -n kube-system # 获取指定名称空间中的指定pod kubectl get pod -n kube-system podName # 获取所有名称空间的pod kubectl get pod -A # 查看pod的详细信息，以yaml格式或json格式显示 kubectl get pods -o yaml kubectl get pods -o json # 查看pod的标签信息 kubectl get pod -A --show-labels # 根据Selector（label query）来查询pod kubectl get pod -A --selector=&quot;k8s-app=kube-dns&quot; # 查看运行pod的环境变量 kubectl exec podName env # 查看指定pod的日志 kubectl logs -f --tail 500 -n kube-system kube-apiserver-k8s-master # 查看所有名称空间的service信息 kubectl get svc -A # 查看指定名称空间的service信息 kubectl get svc -n kube-system # 查看componentstatuses信息 kubectl get cs # 查看所有configmaps信息 kubectl get cm -A # 查看所有serviceaccounts信息 kubectl get sa -A # 查看所有daemonsets信息 kubectl get ds -A # 查看所有deployments信息 kubectl get deploy -A # 查看所有replicasets信息 kubectl get rs -A # 查看所有statefulsets信息 kubectl get sts -A # 查看所有jobs信息 kubectl get jobs -A # 查看所有ingresses信息 kubectl get ing -A # 查看有哪些名称空间 kubectl get ns # 查看pod的描述信息 kubectl describe pod podName kubectl describe pod -n kube-system kube-apiserver-k8s-master # 查看指定名称空间中指定deploy的描述信息 kubectl describe deploy -n kube-system coredns # 查看node或pod的资源使用情况 # 需要heapster 或metrics-server支持 kubectl top node kubectl top pod # 查看集群信息 kubectl cluster-info 或 kubectl cluster-info dump # 查看各组件信息【172.16.1.110为master机器】 kubectl -s https://172.16.1.110:6443 get componentstatuses 操作类命令# 创建资源 kubectl create -f xxx.yaml # 应用资源 kubectl apply -f xxx.yaml # 应用资源，该目录下的所有 .yaml, .yml, 或 .json 文件都会被使用 kubectl apply -f # 创建test名称空间 kubectl create namespace test # 删除资源 kubectl delete -f xxx.yaml kubectl delete -f # 删除指定的pod kubectl delete pod podName # 删除指定名称空间的指定pod kubectl delete pod -n test podName # 删除其他资源 kubectl delete svc svcName kubectl delete deploy deployName kubectl delete ns nsName # 强制删除 kubectl delete pod podName -n nsName --grace-period=0 --force kubectl delete pod podName -n nsName --grace-period=1 kubectl delete pod podName -n nsName --now # 编辑资源 kubectl edit pod podName 进阶类命令# kubectl exec：进入pod启动的容器 kubectl exec -it podName -n nsName /bin/sh #进入容器 kubectl exec -it podName -n nsName /bin/bash #进入容器 kubectl exec -it podName -n nsName -- sh #进入容器 # kubectl label：添加label值 kubectl label nodes k8s-node01 zone=north #为指定节点添加标签 kubectl label nodes k8s-node01 zone- #为指定节点删除标签 kubectl label pod podName -n nsName role-name=test #为指定pod添加标签 kubectl label pod podName -n nsName role-name=dev --overwrite #修改lable标签值 kubectl label pod podName -n nsName role-name- #删除lable标签 # kubectl滚动升级； 通过 kubectl apply -f myapp-deployment-v1.yaml 启动deploy kubectl apply -f myapp-deployment-v2.yaml #通过配置文件滚动升级 kubectl set image deploy/myapp-deployment myapp=&quot;registry.cn-beijing.aliyuncs.com/google_registry/myapp:v3&quot; #通过命令滚动升级 kubectl rollout undo deploy/myapp-deployment 或者 kubectl rollout undo deploy myapp-deployment #pod回滚到前一个版本 kubectl rollout undo deploy/myapp-deployment --to-revision=2 #回滚到指定历史版本 # kubectl scale：动态伸缩 kubectl scale deploy myapp-deployment --replicas=5 # 动态伸缩 kubectl scale --replicas=8 -f myapp-deployment-v2.yaml #动态伸缩【根据资源类型和名称伸缩，其他配置","categories":[],"tags":[{"name":"devops","slug":"devops","permalink":"/tec/devops/"}],"keywords":[]},{"title":"通俗易懂理解it热词","slug":"tec/other/通俗易懂理解it热词","date":"2021-03-01T13:29:01.000Z","updated":"2024-01-11T10:39:04.563Z","comments":true,"path":"2021/03/01/tec/other/通俗易懂理解it热词/","link":"","permalink":"/2021/03/01/tec/other/通俗易懂理解it热词/","excerpt":"","text":"很多同学对热备，冷备，云备了解不深，我科普一下IT行业各种备份术语。以后别闹笑话了。 假设你是一位女性，你有一位男朋友，于此同时你和另外一位男生暧昧不清，比朋友好，又不是恋人。你随时可以甩了现任男友，另外一位马上就能补上。这是冷备份。假设你是一位女性，同时和两位男性在交往，两位都是你男朋友。并且他们还互不干涉，独立运行。这就是双机热备份。假设你是一位女性，不安于男朋友给你的安全感。在遥远的男友未知的地方，和一位男生保持着联系，你告诉他你没有男朋友，你现在处于纠结期，一旦你和你男朋友分开了，你马上可以把自己感情转移到异地男人那里去。这是异地容灾备份。假设你是一位女性，有一位男朋友，你又付了钱给一家婚姻介绍所，让他帮你留意好的资源，一旦你和你这位男朋友分开，婚姻介绍所马上给你安排资源，你感情不间断运行，这是云备份。 数据安全大于一切，今天你把自己备份了吗？ 假设你是一位女性，你怀疑男朋友对你的忠诚，在某宝购买了一个测试忠诚度的服务。这是灾难演练。友情提醒，在没有备份的情况下，切忌进行灾难演练，说不好会让你数据血本无归。假设你是一位女性，你有一位好到不能在好的闺蜜，好到你们可以共享一个男朋友，这是NAS。假设你是一位女性，你男朋友活太好，你一个人根本hold不住，必须要姐妹帮忙才能稳住他。这是负载均衡，QOS。假设你是一位女性，和A吃饭和B逛街和C打炮。合起来是一个完整的男朋友。这是超算集群。建议主频不高的女性不要这样做。会直接死机的。 假设你是一位女性，你的男友沉迷游戏经常不接电话无故宕机，所以当你们约好下午逛街以后你要时不时的打个电话询问，看看他是不是还能正常提供服务，这叫心跳检测。 假设你是一位女性，你想去逛街而你的男友A在打游戏不接电话，于是乎你把逛街的请求发给了替补男友B，从而保障服务不间断运行，这叫故障切换。 假设你是一位女性，你有很多需要男朋友完成的事情，于是乎你跟A逛街旅游吃饭不可描述，而B只能陪你逛街，不能拥有全部男朋友的权利，这叫主从配置 master-slave。 假设你是一位女性，你的需求太强烈以至于你的男友根本吃不消，于是呼你找了两个男朋友，一三五单号，二四六双号限行，从而减少一个男朋友所面临的压力，这叫负载均衡。 假设你是一位女性并且有多个男朋友，配合心跳检测与故障切换和负载均衡将会达到极致的体验，这叫集群LVS，注意，当需求单机可以处理的情况下不建议启用集群，会造成大量资源闲置，提高维护成本。 假设你是一位女性，你的需求越来越高导致一个男朋友集群已经处理不了了，于是乎你又新增了另外几个，这叫多集群，横行扩容，简称multi-cluster grid。 假设你是一位女性，你的男朋友身体瘦弱从而无法满足需求，于是乎你买了很多大补产品帮你男朋友升级，从而提高单机容量，这叫纵向扩容，切记，纵向扩容的成本会越来越高而效果越来越不明显。 假设你是一位女性，你跟男友经常出去游玩，情到深处想做点什么的时候却苦于没有tt，要去超市购买，于是乎你在你们经常去的地方都放置了tt，从而大幅度降低等待时间，这叫CDN。 假设你是一位女性，你的男朋友英俊潇洒风流倜傥财大气粗对你唯一，于是乎你遭到了女性B的敌视，B会以朋友名义在周末请求你男朋友修电脑，修冰箱，占用男朋友大量时间，造成男朋友无法为你服务，这叫拒绝服务攻击，简称DOS。 假设你是一位女性，你因男朋友被一位女性敌视，但是你男朋友的处理能力十分强大，处理速度已经高于她的请求速度，于是她雇佣了一票女性来轮流麻烦你的男朋友，这叫分布式拒绝服务攻击，简称DDOS。 假设你是一位女性，你发现男朋友总是在处理一些无关紧要的其它请求，于是呼你给男朋友了一个白名单，要求他只处理白名单内的请求，而拒绝其它身份不明的人的要求，这叫访问控制，也叫会话跟踪。 假设你是一位女性，你发现采取上述措施以后男朋友的处理请求并没有减少很多，于是你经过调查发现，有人伪造你的微信头像 昵称来向你的男朋友发起请求，这叫跨站点请求伪造 简称CSRF。 假设你是一位女性，你收到了一份快递，于是你要求男朋友给你取快递，当你拿到快递以后发现有人给你邮寄了一封通篇辱骂的信件，这叫跨站点脚本攻击 简称XSS，请注意，对方完全可以给你邮寄微型窃听器来窃听你的隐私。 假设你是一位女性，为了应对威胁，你要求你的男朋友，邮寄给你的邮件必须检查，这叫数据校验与过滤。 假设你是一位女性，你的男朋友太优秀而造人窥视，于是乎它们研究了一下你的男朋友，稍微修改了一点点生产出一个男朋友B 与你的男朋友百分制99相似，这不叫剽窃，这叫逆向工程，比如男朋友外挂。 假设你是一位女性，你要求你的男朋友坚持十分钟，然后十五分钟继而二十分钟以测试你男朋友的极限在哪里，这叫压力测试。 压力测试的目的是查看男朋友是否可以处理需求从而决定是否启用男朋友集群或提升男朋友处理能力，不要对线上运行的男朋友做压力测试，可能会造成宕机的后果，会血本无归的 假设你是一位女性，为了保证你男朋友的正常运行，于是乎你每天查看他的微信微博等社交资料来寻找可能产生问题的线索，这叫数据分析。 假设你是一位女性，你的男朋友属于社交活跃选手，每天的微博知乎微信生产了大量信息，你发现自己的分析速度远远低于他生的速度，于是乎你找来你的闺蜜一起分析，这叫并行计算。 假设你是一位女性，你的男朋友太能折腾处处留情产生了天量的待处理信息，你和你的闺蜜们已经累趴也没赶上他创造的速度，于是你付费在知乎上找了20个小伙伴帮你一起分析，这叫云计算。 假设你是一位女性，在使用云计算后获得了大量整理好的男朋友数据，这些数据如：地点 活跃时间段 活跃次数如家 xxxx 123次汉庭 xxxx 45次…这叫数据统计。 假设你是一位女性，你在得到男朋友经常出没的地点后，根据酒店，敏感时间段等信息确定男朋友因该是出轨了，这叫数据挖掘。 假设你是一位女性，在分析男友的数据后，得知他下午又要出去开房，于是乎你在他准备出门前给他发了个短信，问他有没有带tt，没有的话可以在我这里买，这叫精准推送，需要配合数据挖掘。 假如你是一位女性，你的男朋友总该出去浪而各种出问题，于是乎你租了间屋子并准备好了所有需要的东西并告诉他，以后不用找酒店了，直接来我这屋子吧，什么都准备好了，这叫容器。 以上转载自一个女生不主动联系你还有机会吗？ - 我傻笑你跑掉的回答 - 知乎","categories":[],"tags":[{"name":"other","slug":"other","permalink":"/tec/other/"}],"keywords":[]},{"title":"01-为什么要做CI/CD？","slug":"1.为什么要做CICD","date":"2020-12-04T06:03:30.000Z","updated":"2024-01-11T10:39:04.561Z","comments":true,"path":"2020/12/04/1.为什么要做CICD/","link":"","permalink":"/2020/12/04/1.为什么要做CICD/","excerpt":"","text":"背景-传统的应用开发发布模式开发团队 在开发环境中完成软件开发，单元测试，测试通过，提交到代码版本管理库。 运维团队 把应用部署到测试环境，供QA团队测试，测试通过后部署生产环境。 QA 团队 进行测试，测试通过后通知部署人员发布到生产环境。 问题错误发现不及时 很多 错误在项目的早期可能就存在，到最后集成的时候才发现问题。 人工低级错误发生 产品和服务交付中的关键活动全都需要手动操作。 团队工作效率低 需要等待他人的工作完成后才能进行自己的工作。 开发运维对立 开发人员想要快速更新，运维人员追求稳定，各自的针对的方向不同。 经过上述问题我们需要作出改变，如何改变？ 持续集成与持续交付软件开发的连续方法基于自动执行脚本，以最大程度地减少在开发应用程序时引入错误的机会。从开发新代码到部署新代码，他们几乎不需要人工干预，甚至根本不需要干预。 它涉及到在每次小的迭代中就不断地构建，测试和部署代码更改，从而减少了基于错误或失败的先前版本开发新代码的机会。 此方法有三种主要方法，每种方法都将根据最适合您的策略的方式进行应用。 持续集成 （CI）持续合并开发人员正在开发编写的所有代码的一种做法。通常一天内进行多次合并和提交代码，从存储库或生产环境中进行构建和自动化测试，以确保没有集成问题并及早发现任何问题。 开发人员提交代码的时候一般先在本地测试验证，只要开发人员提交代码到版本控制系统就会触发一条提交流水线，对本次提交进行验证。 持续交付 （CD）持续交付是超越持续集成的一步。不仅会在推送到代码库的每次代码更改时都进行构建和测试，而且，作为附加步骤，即使部署是手动触发的，它也可以连续部署。此方法可确保自动检查代码，但需要人工干预才能从策略上手动触发更改的部署。 持续部署 (CD)通常可以通过将更改自动推送到发布系统来随时将软件发布到生产环境中。持续部署 会更进一步，并自动将更改推送到生产中。类似于持续交付，持续部署也是超越持续集成的又一步。不同之处在于，您无需将其手动部署，而是将其设置为自动部署。部署您的应用程序完全不需要人工干预。 CICD的价值体现 尽早反馈，尽早发现错误。 减少集成问题，每次发现问题当时解决，避免问题堆积。 每次更改都能成功发布，降低发布风险。 更加频繁的交付价值，客户反馈。 推荐常用的CI/CD工具Jenkins专业的CI工具，可扩展自动化服务器、安装配置简单、丰富的插件库、分布式架构设计、支持所有的平台、可视化的管理页面。 GitLab端到端DevOps工具，常用功能：代码审查、问题跟踪、动态订阅、易于扩展、项目wiki、多角色项目管理、项目代码在线编译预览、CI工具集成。 提交合并代码集成 ：通过git push 进行操作或者在GitLab Web页面操作。 发布应用到服务器 ： 获取制品库中的应用，然后用salt、ansible发布部署到服务器。 完全自动化： 提交代码-&gt; 构建部署 -&gt; 发布","categories":[],"tags":[{"name":"devops","slug":"devops","permalink":"/tec/devops/"}],"keywords":[]},{"title":"python向Excel中插入一列内容","slug":"python向Excel中插入一列内容","date":"2020-07-20T07:29:01.000Z","updated":"2024-01-11T10:39:04.562Z","comments":true,"path":"2020/07/20/python向Excel中插入一列内容/","link":"","permalink":"/2020/07/20/python向Excel中插入一列内容/","excerpt":"","text":"在第一列插入一列日期：执行代码后如下所示： # coding:utf-8 from openpyxl import Workbook, load_workbook file_info = &#39;./excel_test/1.xlsx&#39; wb = load_workbook(file_info) ws = wb.worksheets[0] ws.insert_cols(1) for index, row in enumerate(ws.rows): if index == 0: row[0].value = &#39;日期&#39; else: row[0].value = &#39;2020-08-27&#39; wb.save(&#39;./excel_test/3.xlsx&#39;) # row[0]与insert_cols(1)有对应关系，两者相差1","categories":[{"name":"python","slug":"python","permalink":"/essay/python/"}],"tags":[{"name":"code","slug":"code","permalink":"/tec/code/"}],"keywords":[{"name":"python","slug":"python","permalink":"/essay/python/"}]},{"title":"批量修改文件名","slug":"tec/software/批量修改文件名","date":"2020-07-20T07:29:01.000Z","updated":"2024-01-11T10:39:04.563Z","comments":true,"path":"2020/07/20/tec/software/批量修改文件名/","link":"","permalink":"/2020/07/20/tec/software/批量修改文件名/","excerpt":"","text":"批量修改文件名这篇文章推荐一个修改文件名的神器，在这里举个小栗子，我想将下面文件夹下的图片带括号的名字给改成下划线的名字，比如将01 (01).png改成01_01.png，那么这个神器就可以帮助我快速达成我所想要的。 在上面的超链接中下载该软件，下载后双击可执行文件，找到要修改的文件所在的文件夹，点下替换然后在“替换文件中的”中填写想要被替换的符号为自己想要的符号，然后点下预览，就可以看到效果了，如果是自己想要的，就点执行修改。执行修改后，可以看到前面的空格和括号已经被替换成了下划线，然后再把后面的括号替换成空就达到自己的目的了。","categories":[],"tags":[{"name":"software","slug":"software","permalink":"/tec/software/"}],"keywords":[]}]}